<?php
// +----------------------------------------------------------------------+
// | Author:  Evgeny Leontev <eleontev@gmail.com>                         |
// | Copyright (c) 2005-2023 Evgeny Leontev                                    |
// +----------------------------------------------------------------------+
// | This source file is free software; you can redistribute it and/or    |
// | modify it under the terms of the GNU Lesser General Public           |
// | License as published by the Free Software Foundation; either         |
// | version 2.1 of the License, or (at your option) any later version.   |
// |                                                                      |
// | This source file is distributed in the hope that it will be useful,  |
// | but WITHOUT ANY WARRANTY; without even the implied warranty of       |
// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    |
// | Lesser General Public License for more details.                      |
// +----------------------------------------------------------------------+

/**
 * ResultCache is a class used to cache result of your script(function).
 * On first execution of function, execute the function and write returned  
 * data to file(cache), on second execution and more, read data from file.
 * You can specify "how long" cache is valid.
 *
 * SIMPLE EXAMPLE:
 * $sql = "your complex query";
 * function yourFunc($sql) {
 *     $result = mysql_query($sql) or die (db_error());
 *      while($row = mysql_fetch_assoc($result)){
 *         $array[] = $row;
 *     }
 *     return $array;
 * }
 * 
 * $cache = new ResultCache();
 * $cache->setSerialize(true);
 * $cache->setUserFuncVars('yourFunc', $sql);
 * $data = $cache->getData('cache_id');
 *
 *
 * @version 1.0
 * @since 13/08/2003
 * @author Evgeny Leontiev <eleontev@gmail.com>
 * @access public
 */



class ResultCache
{    
    var $cache_dir;                  // directory where cache stored
    var $file_ext;                    // file extension, in which cache will be saved
    var $f_name;
    var $f_param;
    
    var $do_serialize = false;        // serialize or not data, 
                                    // if returned data is array you should serialize it
    var $refresh = false;            // use it for global refresh
    var $exp_time = 0;                // time in minute after that cache will expiered, 
                                    // 0 or false = never expiered 
    static $fname_pattern = '.htcache_%s_%s'; 
    
    /**
     * Class constructor
     *
     * @param    string    $cache_dir    (optional) directory where cache files will be
     * @param    int       $exp_time     (optional) time in minutes after that cache will expired     
     * @access   public
     */
    function __construct($cache_dir = false, $exp_time = 0) {
        $this->cache_dir = $cache_dir;
        $this->exp_time = $exp_time;
    }

    
   /**
    * setSerialize -- set behavior for reading and wring cache.
    *
    * If true data will be serialized before writing cache and unserialized after reading cache
    * Can be used to store resultset from sql query, like array
    *
    * @param     boolean  $set true/false
    * @access    public      
    */
    function setSerialize($set = true) {
        $this->do_serialize = $set;
    }
    
    
   /**
    * setUserFuncVars -- set vars for using in call_user_func_array.
    *
    * to call method for $f_name use array(&$obj, "method_name") syntax.
    *
    * @param    string    $f_name      function name
    * @param    mixed     $f_param     string or array, parameters for function    
    * @access    public      
    */
    function setUserFuncVars($f_name, $f_param = array()) {
        $this->f_name = $f_name;
        $this->f_param = $f_param;
    }
    
    
   /**
    * getData -- get cache or raw data.
    *
    * Get data using function - $f_name or from cache if any
    * if no cache or $refresh = true, write new cache
    *
    * @param    string    $cache_id    id for current cache, use md5 if complex string
    * @param    boolean   $refresh     true if need to refresh data
    *
    * @return   string    data generated by function or from cache
    * @access   public
    */
    function getData($cache_id, $refresh = false) {
        
        $filename = $this->cache_dir . $cache_id . $this->file_ext;
    
        $data = false;
        if($this->exp_time) {
            @$exp_time = (time() - filemtime($filename))/60; 
            if($this->exp_time > floor($exp_time)) {
                $data = FileUtil::read($filename);
            }
        } else {
            $data = FileUtil::read($filename);
        }
        
        if($data === false) { // can't read
            
        }
        
        if($this->refresh || $refresh || !$data) {
            $data = call_user_func_array($this->f_name, $this->f_param);
        
            if($this->do_serialize) { 
                $data = serialize($data); 
            }
            
            $ret = FileUtil::write($filename, $data);
            if($ret === false) { // can't write
            
            }
        }
        
        if($this->do_serialize) { 
            $data = unserialize($data); 
        }
        
        return $data;
    }
    
    
    static function getCache($cache_key, $options) {

        $func = $options['func'];
        $params = (isset($options['params'])) ? $options['params'] : array();
        $minutes = (isset($options['valid'])) ? $options['valid'] : 24*60;

        

        $cache = new ResultCache();
        //$cache->refresh = true;
        
         // time in minute after that cache will expiered, 0 = never expiered
        $cache->exp_time = $minutes; // 24 hours 
        $cache->cache_dir = APP_CACHE_DIR;
        $cache->setUserFuncVars($func, $params);
        $cache->setSerialize(!empty($options['serialize']));

        $roles = '';
        if($roles = AuthPriv::getRoleId()) {
            sort($roles);
            $roles = implode(',', $roles);
        }

        
        if(!empty($options['cache_id'])) { // custom cache_id
            $md5 = md5($options['cache_id']);
        } else {
            $md5 = md5($_SERVER['PHP_SELF'] . $_SERVER['QUERY_STRING'] . AuthPriv::getPrivId() . $roles);
        }
        
        $cache_id = sprintf(self::$fname_pattern, $cache_key, $md5);
        
        return $cache->getData($cache_id);
    }
    
    
    static function destroyGroup($cache_key) {
        $cache = new ResultCache();
        $cache->cache_dir = APP_CACHE_DIR;
        
        $fmask = sprintf(self::$fname_pattern, $cache_key, '*');
        $mask = $cache->cache_dir . $fmask;
        
        $ret = array_map('unlink', glob($mask));
        $ret = (bool) array_filter($ret); // filter empty ones means unlink return false
        
        return $ret; // if at least one unlink failed returns false
    }
    
    
    static function destroyOld($days = 10) {
        $cache = new ResultCache();
        $cache->cache_dir = APP_CACHE_DIR;
        
        $fmask = str_replace('%s_%s', '*', self::$fname_pattern) ;
        $mask = $cache->cache_dir . $fmask;
        
        $ret = array();
        foreach (glob($mask) as $file) {
            if (filemtime($file) < (time() - (60 * 60 * 24 * $days))) { // 2 days
                $ret[] = unlink($file);
            }
        }
        
        $ret = (bool) array_filter($ret); // filter empty ones means unlink return false
        
        return $ret; // if at least one unlink failed returns false
    }
    
    
} // <-- end
?>